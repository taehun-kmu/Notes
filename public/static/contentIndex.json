{"Docker/Docker":{"title":"Docker","links":[],"tags":[],"content":""},"Linux/Default-Commands/Directory_commands":{"title":"Directory","links":[],"tags":[],"content":"1. Directory\n\npwd : 현재 위치 확인\ncd  : 이동\nls  : Directory 안 내용 출력\n\nls -a : 숨긴 파일 모두 출력\nls -d : Directory 자체의 정보 출력\nls -i : incode1 번호 출력\nls -A : ., ..를 제외한 모든 목록 출력2\nls -F : File 종류 표시3\nls -L : Symbolic link 의 경우 원본 File 의 정보 출력\nls -R : 하위 Directory 의 목록 출력\n\n\nmkdir : Directory 생성\n\nmkdir -p : SubDirectory 를 계층적으로 생성할 때 중간 단계의 Directory 를 자동 생성\n\n\nrmdir : Directory delete\n\nFootnotes\n\n\nFile, Directory 에 관한 정보를 가지는 숫자 ↩\n\n\nFile, Directory 의 이름 앞에 붙으면 Hidden File, Directory  - . : Current Directory  - .. : Parent Directory ↩\n\n\n/ : Directory  * : 실행 가능한 File(executable)  @ : 바로가기(Symbolic link)  | : AND(Pipe) ↩\n\n\n"},"Linux/Default-Commands/File":{"title":"File","links":[],"tags":[],"content":"2. File\n\ncat : File 의 내용 출력\n\ncat -n : Row number 붙여 출력\n\n\nmore : File 의 내용을 화면 단위로 출력\n\nmore +number : 출력을 시작할 Row number 를 지정\n\n\nless : File 의 내용을 화면 단위로 출력1\nhead : File 의 1 ~ n Row 까지 출력\n\nhead -Line : 출력할 Row 수를 지정\n\n\ncp : File 이나 Directory 복사\n\ncp -r : SubDirectory &amp; Subfile 까지 모두 복사\ncp -v : 복사 진행 상태 출력\ncp -p : File or Directory 를 복사할 때 복사 대상의 User, Group, Permissions\ncp -i : 복사 대상 File 이 이미 해당 위치에 있다면 User 한테 Overdrive 여부 묻고 복사\ncp -f : 복사 대상 File 이 이미 해당 위치에 있다면 File 을 지우고 강제로 복사\n\n\nrm : File 이나 Directory delete\n\nrm -i : User 한테 여부 묻고 delete\n\n\nln : File link 생성\n\nln -s : Symbolic link file 생성\n\n\ntouch : Empty file 생성\ngreb : (File 내 search) 지정한 Pattern 포함된 Line 찾기   Ex) grep [option][pattern][file]\n\ngrep -c : 일치하는 Row 의 수 출력\ngrep -i : 대소문자 구별 X\ngrep -v : 일치ㅏ하지 않는 Row 만 출력\ngrep -n : 포함된 Row number 함께 출력\ngrep -l : Pattern 이 포함된 File name 출력\ngrep -w : Word 와 일치하는 Row 만 출력\ngrep -x : Line 과 일치하는 Row 만 출력\ngrep -r : SubDirectory 를 포함한 모든 File 에서 search\ngrep -m number 최대로 표시될 수 있는 결과를 제한\ngrep -E : 찾을 pattern 을 정규 포현식으로 찾기\ngrep -F : 찾을 pattern 을 String 으로 찾기\n\n\nfind : 지정한 Path 에서 Search 조건에 맞는 File 찾기   Ex) find [option][path][expressions]2\n\nfind -P : Symbolic link 를 따라가지 않고, Symbolic link 자체 정보 사용\nfind -L : Symbolic link 에 연결된 File 정보 사용\nfind -D : Debug message 출력\n\n\nwhereis : 지정된 Path 에서 Command 의 Binary file 이나 Maual file 의 위치를 찾음\n\nwhereis -b : Binary file 만 Search\nwhereis -m : Maual file 만 Search\nwhereis -s : Source file 만 Search\n\n\n\nFootnotes\n\n\nj : Down key  k : Up key  space bar, Ctrl + f : 다음 Page 이동 \\string : 해당 String 찾기  q : 종료 ↩\n\n\nname : 해당 이름의 File을 찾음(Regex 사용 O)  type : 지정된 File type 에 해당하는 Search for file  user : 해당 User 에게 속한 Search for file  empty : Empty directory 혹은 크기가 0인 Search for file  delete : Search된 File 혹은 Directory delete  exec : Search된 File 에 대해 지정된 Command 실행  path : 지정된 String pattern 에 해당하는 Path 에서 Search  print : Search 결과를 출력, Search 항목을 newline 으로 구분(Default)  print0 : Search 결과를 출력, Search 항목을 null 로 구분  size : File size 를 사용 하여 Search for file  mindepth : Search 을 시작할 SubDirectory 최소 Depth 지정  maxdepth : Search 할 SubDirectory 의 최대 Depth 지정  atime : n 일 이내에 Acess 된 File 찾음  ctime : n 일 이내에 만들어진 File 찾음  mtime : n 일 이내에 수정된 File 을 찾음  cnewer file : 해당 File 보다 최근에 수정된 File 을 찾음 ↩\n\n\n"},"Linux/Default-Commands/vim":{"title":"Edit document","links":[],"tags":[],"content":"3. Edit documents\n\nvi : 지정한 File 편집   PS) vim1을 더 추천\n\n: : Command mode 진입\nq : 종료\nq! : 강제 종료\nw : File 저장\nwq : 저장 후 종료\n\ninsert mode 전환\n\ni : 현재 커서 위치에 insert\nI : 현재 Row 맨 앞에 insert\na : 현재 커서 다음 위치에 insert\nA : 현재 Row 마지막에 insert\no : 아래 Row 에 insert\nO : 위 Row 에 insert\n\n\n커서 Move\n\nw : 다음 Word 첫 character 로 Move\nb : 이전 Word 첫 character 로 Move\nctrl + f : 한 Page 아래로 커서 Move\nctrl + b : 한 Page 위로 커서 Move\nG : 마지막 Row 로 커서 Move\nnumber : n Row 로 커서 Move\n\n\n내용 delete\n\nx : 현재 커서 위치의 한 character delete\nX : 현재 커서 위치 이전한 한 character delete\ndw : 현재 커서 위치의 Word delete\ndb : 현재 커서 위치 이전 Word delete\ndd : 현재 커서 위치의 Row delete\n[number]dd : 현재 커서 위치부터 아래 n Row 을 delete\nd^ : 현재 Row 에서 현재 커서 위치 이전 Row delete\nd$ : 현재 Row 에서 현재 커서 위치 이후 Row delete\n\n\nTake command\n\nu : 이전 Take command\nU : 해당 Row 에서 한 모든 Command 을 take\ne! : 마지막으로 저장한 애용 이후의 것을 모두 Take\nctrl + r : 이전 Take command 을 take\n\n\nCopy &amp; Paste\n\nyy : 현재 커서 위치의 Row 을 copy\n[number]yy : 현재 커서에서 아래의 n Row 을 copy\np : 현재 커서 위치 아래 Row 에 paste\nP : 현재 커서 위치 위 Row 에 paste\nyw : 현재 커서 이후 Copy Word\nyb : 현재 커서 이전 Copy word\n\n\nSearch\n\n/String : String 을 아래 방향으로 Search\n?String : String 을 위 방향으로 검색\nn : 다음 Search for string\nN : 이전 Search for string\n\n\nReplace\n\ns/String-1/String-2 : 현재 커서 위치 Row 에서 첫 번째 나오는 String-1 을 String-2 로 변경\n%s/String-1/String-2 : File 전체에서 모든 String-1 을 String-2 로 변경\n\n\nFile alias\n\nr [file] : 지정한 File 을 읽어 들여 현재 커서 위치로 삽입\ne : 지정한 파일로 전환 - 저장 완료 후 기능\nn : vi 시작 시 여러 File 을 지정했을 경우 다음 File 로 전환\n\n\nPreferences\n\n~/.vimrc 편집\nset nu : File 내용의 각 Row 에 Row number 표시\nset nonu : Row number 표시를 take\nset list : 눈에 보이지 않는 Special character 를 표시\nset showmode : Current mode 표시\nset noshowmode : Current mode 표시 take\nset : set으로 설정한 모든 vi Preferences 값을 출력\nset all : 모든 vi Environment variable 와 Current 값 출력\n\n\n\n\n\n\n\nFootnotes\n\n\n어느정도 익숙해진 뒤 gedit이나 vscode를 쓰지 않고 vim을 더 잘 황용하고 싶다면 nvim을 추천한다.  nvim을 IDE 처럼 쓸 수 있는 여러 프로젝트 들도 있으니 이를 참고 ↩\n\n\n"},"Linux/Directory_Structure":{"title":"Directory structure","links":[],"tags":[],"content":"\nLinux 는 Unix 와 마찬가지로 모든 대상들을 파일로 관리\nDirectory file 들을 관리하기 위해 계층적으로 구성하며 이를 Tree structure\n모든 Directory 의 최상의 Directory 를 Root directory(/)\n\n\n  \n    Directory Location\n    Directory Name\n    Features\n  \n  \n    /\n    /\n    모든 Directory 의 최상의 Directory\n  \n  \n    /bin\n    bin\n    Default command 가 저장된 Directory자주 사용되는 Command 들이 해당 Directory 에 저장\n  \n  \n    /boot\n    boot\n    리눅스의 부팅에 필요한 Information 을 가진 File 들이 저장된 Directory\n  \n  \n    /dev\n    dev\n    시스템 장치 File 을 저장하고 있는 Directory물리적 장치들이 File 형식으로 저장되어 있음\n  \n  \n    /etc\n    etc\n    Linux 의 Preferences file 이 저장된 Directory\n  \n  \n    /home\n    home\n    User 의 Home directory 가 존재하는 곳User를 추가할 때 마다 User ID 명과 동일한 Directory 가 생성된\n  \n  \n    /lib\n    lib\n    Kernel 이 필요로 하는 Libaray, Kernel Module file 이 존재하는 Directory\n  \n  \n    /media\n    media\n    외부 기억장치들의 Mount 연결 시 사용되는 Directory\n  \n  \n    /mnt\n    mnt\n    사용자가 직접 외부 장치들을 Mount 할 때 사용되는 Directory\n  \n  \n    /opt\n    opt\n    추가 응용 프로그램 Package 가 설치되는 Directory\n  \n  \n    /proc\n    proc\n    최상위 Root directory 와 전혀 다른 directory관리자 계정 root 의 Home directory\n  \n  \n    /sbin\n    sbin\n    System Binary file, ifconfig, ethtool 와 같은 System commands 을 저장하고 있는 Directory\n  \n  \n    /usr\n    usr\n    Nomal User 들이 사용하는 Directory\n  \n  \n    /var\n    var\n    Log file 수집, Database Caching file, Web Server image 등 다양한 File 이 존재하는 Directory\n  \n  \n    /sys\n    sys\n    Device 를 관리하기 위한 Virtual File System Directory\n  \n  \n    /run\n    run\n    실행 환경 변수(Run-time variable)를 관리하는 Directory부팅한 후의 System Information 을 관리하는 Directory\n  \n  \n    /tmp\n    tmp\n    임시 File 을 저장하기 위한 Directory\n  \n  \n    /lost + found\n    lost + found\n    Trash 와 같은 개념으로, 삭제된 File 이 저장된 Directory\n  \n"},"Linux/Ubuntu":{"title":"Ubuntu","links":["Linux/Directory_Structure","Linux/Default-Commands/Directory_commands","Linux/Default-Commands/File","Linux/Default-Commands/vim"],"tags":[],"content":"Directory Structure\nDefault Commands\n1. Directory\n2. File\n3. Edit Document"},"ROS/ROS-2":{"title":"ROS 2","links":[],"tags":[],"content":""},"Web/API-Type":{"title":"API Type","links":[],"tags":[],"content":"1 . 1 . 1 API Type\n각 API 는 다음을 정의\n\nProtocol : Control structure\nFormat : Content structure\n\nAPI 종류\n\n  \n  초기 API\n    \n      주로 Local Libaray Function 호출 형태\n    \n  \n  \n  \n  원격 프로시저 호출(RPC)\n    \n      다른 Process 나 Computer 의 Function 를 Local Function 처럼 호출\n      Ex) gRPC1\n    \n  \n  \n  \n  Messaging(RPC)\n    \n      Process 간 Small data Chunk2\n      Command 나 Event 가능\n      Ex) Apache Kafka3, RabbitMQ4, NATS5, ZeroMQ6\n    \n  \n  \n  \n  Communication Pattern(RPC)\n    \n      Request - Response : Web Browser - Web Server\n      Publish - Subscribe(Pub - Sub) : Publisher 가 Message publish, Subscriber 가 선별적으로 Receive\n      Queue : Pub - Sub 와 유사하나 Single Subscriber 만 Message 처리\n    \n  \n\n이 모든 기술들은 Web Service 에서도 Back-end 작업 수행 등에 활용 가능\n\nFootnotes\n\n  \n    grpc.io\n    ↩\n  \n  Piece, Data 를 더 작은 단위로 나눈 것\n    ↩\n  \n  \n    kafka.apache.org\n    ↩\n  \n  \n    www.rabbitmq.com\n    ↩\n  \n  \n    nats.io\n    ↩\n  \n  \n    zeromq.org\n    ↩\n  \n"},"Web/Concurrency":{"title":"Concurrency","links":[],"tags":[],"content":"1 . 2 Concurrency\n\n  Service 가 성장 시 효율성과 확장성이 중요, Latency1 &amp; Throughput2 개선 필요\n  완전한 병렬 처리가 아니라 Busy Waiting3 을 피하는 걸 의미\n\nAsynchronous4 Processing\n\n  Python 은 기본적으론 Synchronous5 이지만,   Asynchronous Processing 도 가능\n  I/O-bound6 Task 에 특히 유용\n  FastAPI 에 Synchronous Processing 을 적용하면 Performance 가 크게 향상\n  CPU 집약적 Task 를 과도하게 수행하지 않도록 주의7\n\nConcurrency 은 Modern Web Service 에서 중요한 개념이며, 적절히 활용하면 Performance 를 크게 개선 가능\n\nFootnotes\n\n  사전 대기 시간\n    ↩\n  \n  Service 와 Caller 간의 초당 Byte 수\n    ↩\n  \n  Process 나 Thread 가 특정 조건이 충족될 때까지 Idle State 로 대기하는 대신,계속해서 해당 조건을 확인하는 Task 를 반복하는 것CPU 자원을 소모하면서 대기하기에 비효율적일 순 있으나, Fast Response 가 필요한 상황에서 사용되기도 함\n    ↩\n  \n  비동기식 : Task 가 시작된 후 완료될 때 까지 기다리지 않고, Other Task 를 병행하여 수행할 수 있는 방식\n    ↩\n  \n  동기식 : Task 가 순차적으로 진행되며, 하나의 Task 가 완료될 때까지 Next Task 가 수행되지 않는 방식\n    ↩\n  \n  Program 이나 Task 가 주로 I/O 에 의해 제한 되는 상태\n    \n      Disk Read/Write, Network Communication, File I/O, etc 에 많은 시간 소요\n      CPU 보다 I/O Task의 속도가 전체 성능을 좌우\n    \n  \n"},"Web/GraphQL":{"title":"GraphQL","links":[],"tags":[],"content":"1 . 1 . 6 GraphQL\nRESTful API 의 한계\n\n특정 상황에서 사용하기 번거로울 수 있음\n\nGraphQL1\n\nFacebook 이 개발한 더 유연한 Query Laungage\nRESTful API 보다 더 유연한 Data Request 기능\n현재로서는 사용할 계획 X\n나중에 여러대의 서버 혹은 확대할 시 적합하지 않다고 생각되면 검토 예정\n\nFootnotes\n\n\ngraphql.org ↩\n\n\n"},"Web/HTTP":{"title":"HTTP","links":[],"tags":[],"content":"1 . 1 . 2 HTTP\nTim Berners-Lee 가 제한한 WWW(World-Wide-Web)의 3가지 핵심 구성요소\n\nHTML : Data Display Language\nHTTP : Client - Server Protocol\nURL : Web Resource Addressing Schema\n\n이 세 가지 요소의 조합은 처음에는 단순해 보였지만, 시간이 지나면서 매우 강력하고 유용한 것으로 입증\nWeb 이 발전하면서 다양한 실험과 혁신(Ex: IMG 태그)이 이루어졌고, 이는 Web 의 필수적인 부분\n이러한 발전 과정에서 웹 표준의 중요성이 부각되어 더욱 체계적인 정의가 이루어지게 됨."},"Web/JSON--and--API-Data-Type":{"title":"JSON & API Data Type","links":[],"tags":[],"content":"1 . 1 . 4 JSON &amp; API Data Type\nJSON(JavaScript Object Notation)\n\nFront-End &amp; Back-End 간 Data 교환을 위한 Text 기반 Format\nList 나 복잡한 Data Structure 를 표현하는 데 적합\n구문은 JavaScript 에서 유래했지만 Python 의 Directory 와 매우 유사\nXML 이나 SOAP 같은 이전의 Data Representation 을 대부분 대체\nModern Web Service 의 I/O Format 으로 널리 사용 중\n간단하고 효율적인 Data Representation 으로, Modern Web Develop 에서 중요한 역할\n"},"Web/JSON_API":{"title":"JSON:API","links":[],"tags":[],"content":"1 . 1 . 5 JSON:API\nRESTful Design &amp; JSON Data Format\n\n조합이 일반화되었지만, 여전히 모호한 부분과 논쟁의 여지가 있음\nJSON:API1는 이러한 문제를 해결하기 위해 더 엄격한 사양 제안\n현재로서는 느슨한 RESTful 방식 사용\n추후 문제 및 논란이 발생할 경우 JSON:API 또는 이와 유사한 엄격한 방식 사용할 예정\n\nFootnotes\n\n\njsonapi.org ↩\n\n\n"},"Web/Layer":{"title":"Layer","links":["Web/HTTP","Media/Vertical-Layer","Media/Horizontal-Layer"],"tags":[],"content":"1 . 3 Layer\nThree-Tier Model\n\nApplication 의 Size 와 복잡성을 관리하기 위해 널리 사용됨\nTerm 은 다양하게 사용되고 있으므로 이름이 다르다고 새로운 개념이 아니며 오랫동안 사용되어 온 방식\n\nTerm\n\nWeb : Client 의 Request 를 수집하고, Service Layer 을 Call 해 Response 하는 HTTP 를 통한 I/O Layer\nService : 필요할 때 Data Layer 를 Call 하는 Business Logic\nData : Data Storage &amp; Other Service 에 접근\nModel : All Layer 가 Share 하는 Data Definition\nWeb Client : Web Browser 또는 Other HTTP Client-Side Software\nDatabase : Data Storage(주로 SQL &amp; NoSQL Server)\n\nTransclude of Vertical-Layer#fig-1---1vertical-layer\nArchitecture\n\nWeb Layer : Client Request 처리 &amp; HTTP I/O 담당\nService Layer : Business Logic 처리\nData Layer : Data 저장 및 접근\nModel Layer : All Layer 가 Share 하는 Data Definition\n\nLayer 분리의 이점\n\n전문성 분리\nTest 격리성\n기능 대체 및 보완 용이\n\nTransclude of Horizontal-Layer#fig-1---2-horizontal-communication-box\nLayer 간 Communication\n\n  API 를 통해 이루어짐\n  각 Layer 간 권장 Data Format 존재\n    \n      Web Client ⇔ Web : JSON 을 사용한 RESTful HTTP\n      Web ⇔ Service : Model\n      Service ⇔ Data : Model\n      Data ⇔ Database &amp; Service : 특정 API\n    \n  \n\nDesign Principles\n\nModualarity : System 을 독립적인 Modual 로 나누어 설계하여 유지보수와 이해 용이\nSingle Response : 각 Modual &amp; Component 를 가지도록 Design 해 복잡성 감소\nOpen/Closed : Software Modual 이 확장에는 열림, 수정에는 닫힘\nReusability : Design 한 Component &amp; Modual 이 Other System &amp; Project 에 재사용\nCoupling &amp; Cohesion : Coupling 감소, Cohesion 증가시켜   각 Modual 간 상호 의존을 줄이고, 각 Modual 기능을 명확히 할 것\nSimplicity : 가능한 Simple 하게 Design 하여 복잡성 감소, 이해와 유지보수 용이\nScalability : System 이 확장되거나 요구 사항이 변경될 때 Simple 하게 확장할 수 있게 Design\n\nCaution\n\nLayer 는 별도의 Program Language Modual 에 대한 간단한 Function 일 수 있으나   어떤 방법 동원 시 External Code 에 접근할 여지가 충분\nLayer 혼합 시 분리 어려움\nLayer 라 부른다고 위 &amp; 아래 에 위치하고, Command 가 내려가는 것이 아님\n얽힌 Code 는 Test 와 이해의 어려움 증가\n"},"Web/REST":{"title":"REST(ful)","links":[],"tags":[],"content":"1 . 1 . 3 REST(ful)\nREST(Representational State Transfer)의 주요 특징\n\n  HTTP Protocol Usage\n  상태 비저장(Stateless)1\n  Cacheable2\n  Resource-based3\n\nRESTful Web Service 의 핵심 개념\n\nResource : 작업을 수행할 수 있는 Data\nEndpoint : 고유한 URL 과 HTTP 동사(동작)로 구성된 기능 접근\n\nHTTP 동사와 CRUD4 Task 의 대응\n\nPOST : 생성(Create)\nGET : 읽기(Read)\nPUT/PATCH : 수정(Update)\nDELETE : 삭제(Delete)\n\nRESTful Communication\n\nRequest : Client 가 Data 를 Header , URL, Quary parameter, 본문에 담아 전송\nResponse : Server 가 State Code, Header, 본문으로 응답\n\nHTTP State Code\n\n1xx : Information\n2xx : Success\n3xx : Redirection\n4xx : Client Error\n5xx : Server Error\n\nPS) 418 State Code(I’m a teapot)는 Web 의 유머러스한 Easter Egg\n\n\nFootnotes\n\n  Server 가 Client 의 이전 Request 를 저장하지 않는 Architecture\n    ↩\n  \n  Data 를 Cache 에 저장할 수 있는 지 여부(Server 로 부터 Re-request 하지 않고 Client Cache 에서 가져올 수 있는 Data)\n    ↩\n  \n  Resource : User 가 식별하고 Task 를 수행할 수 있는 Data특정 System 이나 설계가 Resource 를 중심으로 작동하거나 조작되는 방식\n    ↩\n  \n  Database 의 기본 동작\n    \n      쓰기(Create)\n      읽기(Read)\n      수정(Update)\n      삭제(Delete)\n    \n  \n"},"Web/Service--and--API":{"title":"Service & API","links":["Web/API-Type","Web/HTTP","Web/REST","Web/JSON--and--API-Data-Type","Web/JSON_API","Web/GraphQL"],"tags":[],"content":"1 . 1 Service &amp; API\n\n  \n    API1 의 중요성\n      \n        Front-end &amp; Back-end 간 Communication 수단\n        Modern Web 에서 API design 의 중요성이 Website Design 만큼 중요\n      \n  \n  \n  \n    API 의 역할\n      \n        Database Schema2 와 유사한 규약 역할\n        API 정의와 수정, 중차대한 작업\n      \n  \n\nSubtitle\n\nAPI Type\nHTTP\nREST(ful)\nJSON &amp; API Data Type\nJSON:API\nGraphQL\n\n\nFootnotes\n\n  Application Programming Interface\n    ↩\n  \n  Database System 에서 Structure, 구성 및 관계를 정의\n    ↩\n  \n"},"Web/Web":{"title":"Modern Web","links":[],"tags":[],"content":"1. Web 의 역할 변화\n\n전통적으는 Content 중심이었으나, 현재는 API1를 통한 연결성이 중요\n\n2. Web 개발의 분화\n\nFront-end : UI2 제공(JS, Mobile App, etc)\nBack-end : Database 접근과 Business Logic3 처리\n\nFootnotes\n\n\nApplication programming Interface ↩\n\n\nUser Interface ↩\n\n\nProgram 의 핵심 Logic(어떻게 Data 가 생성되고 저장되고 수정되는지를 정의) ↩\n\n\n"},"index":{"title":"Welcome to KMU-FMCL Docs","links":["Linux/Ubuntu","Docker/Docker","ROS/ROS-2","Web/Web","Web/Service--and--API","Web/Concurrency","Web/Layer","Data","project"],"tags":[],"content":"OS\n\nUbuntu\n\nSoftware\n\nDocker\nROS\n\nWeb\n\nService &amp; API\nConcurrency\nLayer\nData\n\nFMCL API Server Project\ngantt\n    title 2024년 9월 프로젝트 일정\n    dateFormat  YYYY-MM-DD\n    axisFormat %m/%d\n\n    section 개발 단계\n    서버(로컬)-클라이언트 데이터 전송 테스트 : 2024-09-01, 7d\n    도커 적용                               : 2024-09-08, 7d\n    API 서버 권한 수정 및 호출 제한         : 2024-09-15, 7d\n    통합 테스트 및 에러 체크                : 2024-09-22, 7d\n    인증 권한 토큰 작업                     : 2024-09-29, 7d\n    서버 테스트 (완성 목표)                 : 2024-10-06, 7d\n    디버깅                                  : 2024-10-13, 14d\n\nSee the documentation for how to get started."},"Media/Vertical-Layer":{"title":"Vertical Layer","links":[],"tags":[],"content":"Fig 1 - 1 Vertical Layer\n\n\n"},"Media/Horizontal-Layer":{"title":"Horizontal Layer","links":[],"tags":[],"content":"Fig 1 - 2 Horizontal Communication Box\n\n\n"},"project":{"title":"FMCL API Server Project","links":[],"tags":[],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeekTask1th서버(로컬) - 클라이언트 간 데이터 양방향 전송 테스트2th도커 적용3thAPI 서버 권한 수정 및 클라이언트 호출 제한4th통합 테스트 및 에러 체크5th인증 권한 토큰 작업6th서버 테스트(완성 목표)7 ~ 8 th디버깅\n\n시험기간 고려해서 6주차까지 완성 후 7 ~ 8주차에 보완 &amp; 개선 중심으로 목표로 하고 있습니다.\n\n1주차 테스트\n\n파일 인덱싱 &amp; IO\n사진 Test\n녹화 영상 Test\n실시간 영상 Test\n\n\n대략 이렇게 개요를 잡고 있습니다.\n\nPS)\n진도가 늦어지는 점 죄송합니다.  현재 Github Pages 에 공부 자료를 우선적으로 올리는 것을 중점으로 문서를 꾸려나가고 있습니다.  시간이 되시면 혹여나 틀린 점이 있을 시 메일 보내주시면 확인하는대로 신속하게 수정해놓도록 하겠습니다."}}